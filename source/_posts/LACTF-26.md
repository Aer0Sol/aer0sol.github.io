---
date: 2026-02-09
title: "LACTF 2026 Crypto challenges"
toc: true
description: "Couple of writeups primarily crypto for LACTF 2026"
math: true
cover: /images/covers/LACTF_top.jpg
tags: 
- Isomorphism
- Hash length extension
- Polynomial
categories: Writeup
---



Here are some of the challenges I solved during LACTF 2026, overall pretty fun CTF.
Challenge files can be found at this archive : [--> Sajjadium](https://github.com/sajjadium/ctf-archives/tree/main/ctfs/LA/2026/crypto/the_clock)

## The Clock

### Challenge Description

```
Don't run out of time
```

### Source Code Analysis

- We can deduce some form of DH key exchange is happening and there is some sort of Finite Field that is being constructed with the redacted prime `p`.
- There is this _sus_ func: 
  ```python
  def clockadd(P1,P2):
  x1,y1 = P1
  x2,y2 = P2
  x3 = x1*y2+y1*x2
  y3 = y1*y2-x1*x2
  return x3,y3
  ```
  This is not the regular elliptic curve addition and reminded me a bit of Edwards curve addition.
-  Anyway after a bit of searching and reading this [PDF](https://www.hyperelliptic.org/tanja/teaching/crypto21/ecc-2.pdf), the `clockadd()` func is similar to addition over the unit circle. 

### The maths

The entire `clockadd()` is just addition of angles over a circle, so we can see how: 
$$\sin(a+b) = \sin(a)\cos(b) + \cos(a)\sin(b)$$
$$\cos(a+b) = \cos(a)\cos(b) - \sin(a)\sin(b)$$
So now can we just map $(x,y)  \to (\sin(\theta), \cos(\theta))$ and we can see how the `clockadd()` func came to be.

We still lack `p` the modulus used for the FF operations, how can we retrieve it? 
Quite simple actually, we are given three elements from this curve and the corresponding equation each one of them satisfy is $$x^2 + y^2 \equiv \bmod \ p$$ We can simply rearrange this for getting $x^2 -y^2 - 1 = k\cdot p$ 
Perform this for each element given (Alice, Bob and Base Point) and take the gcd, that will be the `p` with high chance
```python
p = gcd([Ax^2 + Ay^2 - 1, Bx^2 + By^2 - 1, Gx^2 + Gy^2 - 1])
assert is_prime(p) 
```

Now we can check if `p-1` is smooth which turns out to be a no, we can also see $p \equiv 3  \bmod 4$
Since we are dealing with a circle rather than a traditional elliptic curve, let's look for an `isomorphism` to ease out the difficulty of our problem.
We can try using the unit circle over complex plane but we have to first include $i$ somehow.

We can notice how there exists no solution to the equation $x^2 \equiv -1 \bmod p$ so let's perform a field extension.
We can now build:  $$\mathbb{F}_{p^2} \cong \mathbb{F}_{p}[x]/⟨x^2+1⟩$$
which in sage is: 
```python
F = GF(p^2, 'i', modulus=[1,0,1])
i = F.gen()
```

Intuition stems from the fact the algebraic structure over the complex numbers still looks a circle, we can now see if the order is smooth and it indeed is.

### Exploit Script
```python
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad

Ax,Ay = (13109366899209289301676180036151662757744653412475893615415990437597518621948, 5214723011482927364940019305510447986283757364508376959496938374504175747801)
Bx,By = (1970812974353385315040605739189121087177682987805959975185933521200533840941, 12973039444480670818762166333866292061530850590498312261363790018126209960024)
Gx,Gy = (13187661168110324954294058945757101408527953727379258599969622948218380874617, 5650730937120921351586377003219139165467571376033493483369229779706160055207)

ct = 'd345a465538e3babd495cd89b43a224ac93614e987dfb4a6d3196e2d0b3b57d9'

p = gcd([Ax^2 + Ay^2 - 1, Bx^2 + By^2 - 1, Gx^2 + Gy^2 - 1])
assert is_prime(p) 
print(f'p = {p % 4} mod 4')

F = GF(p^2, 'i', modulus=[1,0,1])
i = F.gen()

def conv_complex(Px,Py):
    return F(Px) + F(Py)*i

Az = conv_complex(Ax,Ay)
Bz = conv_complex(Bx,By)
Gz = conv_complex(Gx,Gy)

a = discrete_log(Az,Gz)
print(f'[!] Alice secret: {a}')

Sz = Bz^a 
Sx,Sy = Sz[0],Sz[1]
from hashlib import md5

key = md5(f"{Sx},{Sy}".encode()).digest()
cipher = AES.new(key, AES.MODE_ECB)
flag = unpad(cipher.decrypt(bytes.fromhex(ct)),16).decode()
print(flag)
```

**Flag** : `lactf{t1m3_c0m3s_f4r_u_4all}`


## Spreading Secrets

### Challenge Description

```
I heard you like sharing secrets, so I shared my secret with the polynomial that shares the secret.
```

### Source Code Analysis

- Challenge premise is Shamir's Secret Sharing Scheme but the coefficients are generated by a PRNG.
- The PRNG in question:
  ```python
  class RNG:
    def __init__(self, seed, modulus):
        self.state = seed
        self.a = ... #vals are provided btw
        self.b = ...
        self.c = ...
        self.d = ...
        self.modulus = modulus

    def next(self):
        self.state = (
            self.a * self.state**3
            + self.b * self.state**2
            + self.c * self.state
            + self.d
        ) % self.modulus
        return self.state
  ```
  
- So each state is represented as a polynomial of degree 3 (recurrence relation) and the next state is derived from the previous state.
- This obviously means if we are going to represent this as a polynomial, the degree is gonna increase for each `RNG.next()` call.
- The total number of shares is 15 and we need only 10 to interpolate the polynomial.
- A single share $(x=1,y)$ is provided along with the modulus. 
- Since it is the very first share,
$$y = \sum^{9}_{i=0} c_{i} \bmod p$$
- As I had mentioned before, if we are to represent the seed, i.e $P(c\_{0})$,
the polynomial degree would be $3^9 = 19683$ (waw)

### The math

We can first construct $Q(x) = P(x) - y$  where is $P(x)$ is the polynomial involved in the SSSS under $\mathbb{F}_{p}[x]$. The roots of this polynomial would be the **seed**.
Now we end up in an amazing position, we can't possibly compute `.roots()` of such an enormous polynomial (atleast I ended up failing -- idk why I tried honestly) so let's think of other ways. 

Fortunately, 
we can try something with binary exponentiation. We can do $R(x) \equiv x^p \bmod Q(x)$ and then compute $gcd(R(x)-x, Q(x))$ and this resulting polynomial contains all the roots of $Q(x)$ that is under $\mathbb{F}\_{p}[x]$  
Why?
$x^p - x$ has a nice property where it is the product of each and every number in $\mathbb{F}\_{p}$ i.e 
$$x^p - x = \prod_{i \in \mathbb{F\_{p}}}(x-i)$$
so we can just use `gcd()` as a nice filter.

Let's name this new polynomial as $S(x)$ and thankfully the degree of $S(x)$ is just 2 so we can compute the roots and try each until we can decode it into the flag.

### Exploit Script

```python
from Crypto.Util.number import long_to_bytes as l2b

a = 4378187236568178488156374902954033554168817612809876836185687985356955098509507459200406211027348332345207938363733672019865513005277165462577884966531159
b = 5998166089683146776473147900393246465728273146407202321254637450343601143170006002385750343013383427197663710513197549189847700541599566914287390375415919
c = 4686793799228153029935979752698557491405526130735717565192889910432631294797555886472384740255952748527852713105925980690986384345817550367242929172758571
d = 4434206240071905077800829033789797199713643458206586525895301388157719638163994101476076768832337473337639479654350629169805328840025579672685071683035027
p = 12670098302188507742440574100120556372985016944156009521523684257469947870807586552014769435979834701674318132454810503226645543995288281801918123674138911
y1 = 6435837956013280115905597517488571345655611296436677708042037032302040770233786701092776352064370211838708484430835996068916818951183247574887417224511655


def next_state(s):
    return a*s^3 + b*s^2 + c*s + d

def build_poly(x):
    build = x
    poly = build
    for _ in range(9):
        build = next_state(build)
        poly += build

    poly -= y1
    return poly.monic()

Z = Zmod(p)
R.<x> = PolynomialRing(Z)

f = build_poly(x)

xp = pow(x, p, f)
g = f.gcd(xp - x)

for r, _ in g.roots():
    val = int(r)
    try:
        print(l2b(val).decode())
    except:
        continue
```

Flag : `lactf{d0nt_d3r1v3_th3_wh0l3_p0lyn0m14l_fr0m_th3_s3cr3t_t00!!!}`


