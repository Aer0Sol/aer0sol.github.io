---
date: 2026-02-09
title: "LACTF 2026 Crypto challenges"
toc: true
description: "Couple of writeups primarily crypto for LACTF 2026"
math: true
cover: /images/covers/LACTF_top.jpg
tags: 
- Isomorphism
- Polynomial
- Hash length extension
categories: Writeup
---



Here are some of the challenges I solved during LACTF 2026, overall pretty fun CTF.
Challenge files can be found at this archive : [--> Sajjadium](https://github.com/sajjadium/ctf-archives/tree/main/ctfs/LA/2026/crypto/the_clock)

## The Clock

### Challenge Description

```
Don't run out of time
```

### Source Code Analysis

- We can deduce some form of DH key exchange is happening and there is some sort of Finite Field that is being constructed with the redacted prime `p`.
- There is this _sus_ func: 
  ```python
  def clockadd(P1,P2):
  x1,y1 = P1
  x2,y2 = P2
  x3 = x1*y2+y1*x2
  y3 = y1*y2-x1*x2
  return x3,y3
  ```
  This is not the regular elliptic curve addition and reminded me a bit of Edwards curve addition.
-  Anyway after a bit of searching and reading this [PDF](https://www.hyperelliptic.org/tanja/teaching/crypto21/ecc-2.pdf), the `clockadd()` func is similar to addition over the unit circle. 

### The maths

The entire `clockadd()` is just addition of angles over a circle, so we can see how: 
$$\sin(a+b) = \sin(a)\cos(b) + \cos(a)\sin(b)$$
$$\cos(a+b) = \cos(a)\cos(b) - \sin(a)\sin(b)$$
So now can we just map $(x,y)  \to (\sin(\theta), \cos(\theta))$ and we can see how the `clockadd()` func came to be.

We still lack `p` the modulus used for the FF operations, how can we retrieve it? 
Quite simple actually, we are given three elements from this curve and the corresponding equation each one of them satisfy is 
$$x^2 + y^2 \equiv \bmod \ p$$
We can simply rearrange this for getting $x^2 + y^2 - 1 = k\cdot p$ 
Perform this for each element given (Alice, Bob and Base Point) and take the gcd, that will be the `p` with high chance
```python
p = gcd([Ax^2 + Ay^2 - 1, Bx^2 + By^2 - 1, Gx^2 + Gy^2 - 1])
assert is_prime(p) 
```

Now we can check if `p-1` is smooth which turns out to be a no, we can also see $p \equiv 3  \bmod 4$
Since we are dealing with a circle rather than a traditional elliptic curve, let's look for an `isomorphism` to ease out the difficulty of our problem.
We can try using the unit circle over complex plane but we have to first include $i$ somehow.

We can notice how there exists no solution to the equation $x^2 \equiv -1 \bmod p$ so let's perform a field extension.
We can now build:  
$$\mathbb{F}_{p^2} \cong \mathbb{F}_{p}[x]/âŸ¨x^2+1âŸ©$$
which in sage is: 
```python
F = GF(p^2, 'i', modulus=[1,0,1])
i = F.gen()
```

Intuition stems from the fact the algebraic structure over the complex numbers still looks a circle, we can now see if the order is smooth and it indeed is.

### Exploit Script
```python
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad

Ax,Ay = (13109366899209289301676180036151662757744653412475893615415990437597518621948, 5214723011482927364940019305510447986283757364508376959496938374504175747801)
Bx,By = (1970812974353385315040605739189121087177682987805959975185933521200533840941, 12973039444480670818762166333866292061530850590498312261363790018126209960024)
Gx,Gy = (13187661168110324954294058945757101408527953727379258599969622948218380874617, 5650730937120921351586377003219139165467571376033493483369229779706160055207)

ct = 'd345a465538e3babd495cd89b43a224ac93614e987dfb4a6d3196e2d0b3b57d9'

p = gcd([Ax^2 + Ay^2 - 1, Bx^2 + By^2 - 1, Gx^2 + Gy^2 - 1])
assert is_prime(p) 
print(f'p = {p % 4} mod 4')

F = GF(p^2, 'i', modulus=[1,0,1])
i = F.gen()

def conv_complex(Px,Py):
    return F(Px) + F(Py)*i

Az = conv_complex(Ax,Ay)
Bz = conv_complex(Bx,By)
Gz = conv_complex(Gx,Gy)

a = discrete_log(Az,Gz)
print(f'[!] Alice secret: {a}')

Sz = Bz^a 
Sx,Sy = Sz[0],Sz[1]
from hashlib import md5

key = md5(f"{Sx},{Sy}".encode()).digest()
cipher = AES.new(key, AES.MODE_ECB)
flag = unpad(cipher.decrypt(bytes.fromhex(ct)),16).decode()
print(flag)
```

**Flag** : `lactf{t1m3_c0m3s_f4r_u_4all}`


## Spreading Secrets

### Challenge Description

```
I heard you like sharing secrets, so I shared my secret with the polynomial that shares the secret.
```

### Source Code Analysis

- Challenge premise is Shamir's Secret Sharing Scheme but the coefficients are generated by a PRNG.
- The PRNG in question:
  ```python
  class RNG:
    def __init__(self, seed, modulus):
        self.state = seed
        self.a = ... #vals are provided btw
        self.b = ...
        self.c = ...
        self.d = ...
        self.modulus = modulus

    def next(self):
        self.state = (
            self.a * self.state**3
            + self.b * self.state**2
            + self.c * self.state
            + self.d
        ) % self.modulus
        return self.state
  ```
  
- So each state is represented as a polynomial of degree 3 (recurrence relation) and the next state is derived from the previous state.
- This obviously means if we are going to represent this as a polynomial, the degree is gonna increase for each `RNG.next()` call.
- The total number of shares is 15 and we need only 10 to interpolate the polynomial.
- A single share $(x=1,y)$ is provided along with the modulus. 
- Since it is the very first share,
$$y = \sum^{9}_{i=0} c_{i} \bmod p$$
- As I had mentioned before, if we are to represent the seed, i.e $P(c\_{0})$,
the polynomial degree would be $3^9 = 19683$ (waw)

### The math

We can first construct $Q(x) = P(x) - y$  where is $P(x)$ is the polynomial involved in the SSSS under $\mathbb{F}_{p}[x]$. The roots of this polynomial would be the **seed**.
Now we end up in an amazing position, we can't possibly compute `.roots()` of such an enormous polynomial (atleast I ended up failing -- idk why I tried honestly) so let's think of other ways. 

Fortunately, 
we can try something with binary exponentiation. We can do $R(x) \equiv x^p \bmod Q(x)$ and then compute $gcd(R(x)-x, Q(x))$ and this resulting polynomial contains all the roots of $Q(x)$ that is under $\mathbb{F}\_{p}[x]$  
Why?
$x^p - x$ has a nice property where it is the product of each and every number in $\mathbb{F}\_{p}$ i.e 
$$x^p - x = \prod_{i \in \mathbb{F\_{p}}}(x-i)$$

_hint: Fermat's little theorem :)_

$Q(x)$ obviously has multiple factors but it would also contain factors that are irreducible and greater than degree 1, which are garbage factors and we need not worry about those anyway.
so we can just use `gcd()` as a nice filter.

Let's name this new polynomial as $S(x)$ and thankfully the degree of $S(x)$ is just 2 so we can compute the roots and try each until we can decode it into the flag.

### Exploit Script

```python
from Crypto.Util.number import long_to_bytes as l2b

a = 4378187236568178488156374902954033554168817612809876836185687985356955098509507459200406211027348332345207938363733672019865513005277165462577884966531159
b = 5998166089683146776473147900393246465728273146407202321254637450343601143170006002385750343013383427197663710513197549189847700541599566914287390375415919
c = 4686793799228153029935979752698557491405526130735717565192889910432631294797555886472384740255952748527852713105925980690986384345817550367242929172758571
d = 4434206240071905077800829033789797199713643458206586525895301388157719638163994101476076768832337473337639479654350629169805328840025579672685071683035027
p = 12670098302188507742440574100120556372985016944156009521523684257469947870807586552014769435979834701674318132454810503226645543995288281801918123674138911
y1 = 6435837956013280115905597517488571345655611296436677708042037032302040770233786701092776352064370211838708484430835996068916818951183247574887417224511655


def next_state(s):
    return a*s^3 + b*s^2 + c*s + d

def build_poly(x):
    build = x
    poly = build
    for _ in range(9):
        build = next_state(build)
        poly += build

    poly -= y1
    return poly.monic()

Z = Zmod(p)
R.<x> = PolynomialRing(Z)

f = build_poly(x)

xp = pow(x, p, f)
g = f.gcd(xp - x)

for r, _ in g.roots():
    val = int(r)
    try:
        print(l2b(val).decode())
    except:
        continue
```

**Flag** : `lactf{d0nt_d3r1v3_th3_wh0l3_p0lyn0m14l_fr0m_th3_s3cr3t_t00!!!}`






Now let's get to the most enjoyable solve of the CTF for me, that involved *some* tetris




## Ttyspin

### Challenge Description
```
Ready for a classic, yet modern gaming experience?
```

### Source Code Analysis

- We are given two files, [game.py](https://github.com/sajjadium/ctf-archives/blob/main/ctfs/LA/2026/crypto/ttyspin/game.py) and [board.py](https://github.com/sajjadium/ctf-archives/blob/main/ctfs/LA/2026/crypto/ttyspin/board.py) so let's analyse each one of them separately.

#### game.py
- If we look at `game.py` there are couple of interesting stuff, we have a `winning_board` var which is a matrix comprising mostly of 0s but some digits in a zigzag manner.
- there is a `make_checksum()` func which takes in a username and save_code, has an assertion where `assert len(SECRET) == 40` happens and returns: `Hash((SECRET + username + save_code).strip())` definitely very interesting as you will see soon.
- Some standard funcs that you would associate with how the game renders elements and such, not very useful and interesting..
- Under main, we have give username as an input which should not exceed 32 length and a load from save functionality where it prompts for checksum val in hex and checks it against `make_checksum(username, base64.b64decode(save)).encode()` if it the checksum matches, the game loads from the given save, again interesting mechanism.
- Couple of keybinds and set actions for them in the rest of the code and there is a check which **fetches our board and compares it against the winning board** if they match, we get the flag.

#### board.py
- We see a bunch of block_shapes, kicks and a dict with piece_to_type
- We have two classes, one is `Board` and the other is `Block` seems to contain everything you would normally expect from a tetris game, nothing really special here (I manually did go through the functions line by line to deduce nothing really special there ðŸ’€)
- Except of-course for the save functionality, which describes how to load a save when provided one.

Overall, we are looking at quite some interesting mechanism associated with save functionality and the checksum derivation from the username and save_code.

### How does the game work?

- So we know this works like usual tetris from reading the code and most importantly _playing_ it, we have all the usual blocks which are T, J, L, S, Z, O and finally the I block.
- We can **hold** a block, i.e, we can mark a block as held and the block will now disappear and the next block in the queue will appear on the screen. If this was done when there is already a block held, the current block will swap out with the current block **but this action cannot be done again until unless this block is placed.**
![Local_example](local_example.png)

We can load a game from a save, we can also export our current game in the checksum format.

![Local_save](local_save.png)

- Let's see how the save_code is represented:
`current, hold, nexts, queue, board = save.decode().split("|")`
from this we can deduce that our currently active block is stored first, then the held block, next array, queue array and finally the board of length `200`

- Let's convert the above image's save_code and see:
```
'L|S|ZIZT|SOLJI|                                                                                                                                                                           OO  T    JOO  TT   JJJ  T    '
```

- `All the gaps that you can see is/are the air/places where there are no blocks placed.`

Now, as we have an idea how the board is represented, we can move our focus to the `checksum` especially on how it is formed.

Let's have a visualization:
![Full hash](hash_full.png)

- We have 40 byte `SECRET` value that is appended to our username and save_code which let's assume is randomly generated, this prevents us from outright forging a game state we want for an username.

_BUT_

**We are using a Merkleâ€“DamgÃ¥rd hash function (SHA256 here) which is vulnerable to [Hash Length Extension Attack](https://en.wikipedia.org/wiki/Length_extension_attack), can we do something possibly with it?**

### Small Primer of Length Extension

- All MD hash functions use a **compression function** internally to create the hash but it cannot take arbitrary length data, so a **MD-compliant padding function** is applied to create an input of size which is a multiple of 512 bits in the case of SHA256.
- This result is then broken down as blocks of fixed size and they are processed one at a time with $f$ .

![MD Construction](MD_cons.png)

- Since they are processed one at a time, given `H(X)` for an unknown value `X`, we can easily find the value of `H(pad(X)|Y)` for a chosen value `Y`. This requires you to know the length of the unknown so you can perform the Hash's padding.

### The Exploitation

We know we have to perform Hash Length Extension of some kind BUT we have a problem,  we simply can't query `H(SECRET)`, we have to worry about the username and save_code, to circumvent, we can do the following
- Use an empty string for an username so our hash now looks like: 
![New hash](new_hash.png)

So we have to worry only about the save_code state.
But that is also a problem as:
- save_code contains the **board state**, which is exactly what we are trying to forge
Simple, can we not save at the start of the game so there is nothing in the screen placed?
NO, because of this line in `game.py` under `draw_save_window()`:

```python
    if game_board.score == 0:
        window.addstr(7, 2, "No point in exporting, place some pieces")
```

So the only option is to get a **Perfect Clear Opener** for which I referred this [blog](https://four.lol/perfect-clears/opener#vertical-i) (I was pretty much baffled when I saw the speed of the PCOs T-T)
which means me and my teammate had to skill up in tetris...

Basically..
![PCO Block](PCO_block.png)

if we can form these structures in the game in some orientation with the I block on hold, we have 86.64% of a PCO.

so we tried and tried...
local recreation of this masterpiece:
![Local PCO 1](local_PCO1.png) ![Local PCO 2](local_PCO2.png)

NOW, we can do Hash Length Extension because this is how our checksum construction would look like:
![Local full hash](local_fhash.png)

since there is a `.strip()` happening, all the "air" will be eliminated, so we save the state, get the save_code and checksum.

We can perform the appropriate MD-compliant padding for round-info since that will now occupy the place of our username and we hash-extend.

```python
import hlextend

H = hlextend.new('sha256')
pay = 'Z|I|JSTI|SLZOJ|'
add = 'Z|I|JSTI|SLZOJ|          I          S          O          L          Z          T          J          I          S          O        L        Z        T        J        I        S        O        L        Z'
print(len(add))
'''
Z|I|JSTI|SLZOJ|          I          S          O          L          Z          T          J          I          S          O        L        Z        T        J        I        S        O        L        Z
'''
print(H.extend(add.encode(), pay.encode(), 40, '76127818b168396db49461ea9a28255c701b6838cfbf24ce9f794640ef1b5854'))
print(H.hexdigest())
```

We can send this now to the server:

### Exploit Script

```python
import pexpect
import time

host = 'chall.lac.tf'
port = 32123
user = 'ttyspin'
password = user.encode()

checksum = b"b230b8bc375c6c45f315f3f09f14f2cc0fc700f88e16077e43ca9c0e03ebbeb5"
username = b'Z|I|JSTI|SLZOJ|\x80\x00\x00\x00\x00\x00\x00\x01\xb8'
b64_savestate = b'WnxJfEpTVEl8U0xaT0p8ICAgICAgICAgIEkgICAgICAgICAgUyAgICAgICAgICBPICAgICAgICAgIEwgICAgICAgICAgWiAgICAgICAgICBUICAgICAgICAgIEogICAgICAgICAgSSAgICAgICAgICBTICAgICAgICAgIE8gICAgICAgIEwgICAgICAgIFogICAgICAgIFQgICAgICAgIEogICAgICAgIEkgICAgICAgIFMgICAgICAgIE8gICAgICAgIEwgICAgICAgIFogICAgICAgICA='

cmd = f'ssh -p {port} {user}@{host}'

def solve():
    print("Cooking...")
    child = pexpect.spawn(cmd)

    def ce(x): child.expect(x.encode())
    def cs(x): child.sendline(x)
    child.delaybeforesend = 0
    
    ce('password:')
    cs(password)
    
    ce('username:')
    cs(username)
    
    ce('save code')
    cs(b64_savestate)
    
    ce('Checksum')
    cs(checksum)
    
    try:
        time.sleep(2)
        res = child.read_nonblocking(size=10000, timeout=10)
        out = res.decode(errors='replace')
        print(out)
        if "Congratulations" in out:
            print("\n[+] Flag has been found!")
    except Exception as e:
        print(f"Error: {e}")
    
    child.close()

solve()
```

**Flag** : `lactf{T3rM1n4L_g4mE5_R_a_Pa1N_2e075ab9ae6ae098}`
