---
date: 2025-10-26
title: "Cybermimic Defense 2025 Crypto - FMS"
toc: true
description: "Writeup on a Cybermimic Defense'25 crypto challenge"
math: true
cover: /images/covers/FMS_top.gif
tags: 
- Lattice
- LCG
- PRNG
categories: Writeup
---



### Challenge Description

```
The developer of the Flag management system seems to have implanted a backdoor into this system. As a tester, can you find the backdoor and obtain the flag?
```


### Given information

We are working with a truncated LCG which outputs its lsb bits via the `vcode` var. We are additionally give the modulus `p`, increment `b` and the multiplier `a`. 

### Analysis

-  The prng is called 32 times because of this one line : `sha256(("".join(prng.choices(ascii_letters + digits, 32))).encode()).hexdigest()` for constructing the admin's password
- The actual outputs are given as `prng.randbytes(4)` which internally calls the prng with `prng.next() % 256` 4 times and gives the outputs as bytes.
- Upon logging in as admin after performing a state recovery on the prng, we get the key, iv which are generated by `prng.randbytes(16)` and then we also get the flag as the ciphertext.

### Approach

- Very standard lattice attack case except working with lsb, I personally spent a lot of time reading [lsb-msb calc game blog by Joseph ](https://jsur.in/posts/2020-09-20-downunderctf-2020-writeups#lsb-msb-calculation-game) and then tweaking [jvdsn's script](https://github.com/jvdsn/crypto-attacks/blob/master/attacks/lcg/truncated_state_recovery.py) for the msb case.
-  Grok gave me a state transformation variation of the script where each state is transformed as: $$s_{i} \equiv x_{i} \cdot 2^{-8} \bmod p$$ where $x_{i}$ is the state and c is now: $$c^{'} \equiv b\cdot 2^{-8} \bmod p $$
- This yields a new LCG where our lsb bits are the msb and now we can feed to the existing attack script. There are certain edge cases with wrapping but grok was kind enough to do all of that.
- This gives us the state *right after*  initial admin password generation, therefore requiring a simple rollback of 33 states. It is trivial as all the states are now known.
- We query the correct admin password generated by the prng and login, replicate the key and iv generation and finally aes cbc decrypt to get the flag.


### Solve script
```python
from pwn import * 
import os
import pty
from Crypto.Util.number import *
from Crypto.Util.Padding import unpad
from Crypto.Cipher import AES
from hashlib import sha256
from random import randrange
from string import ascii_letters, digits
from binascii import unhexlify
from sage.all import QQ, ZZ, matrix, vector
from fpylll import *

class PRNG:
    def __init__(self, a=None, b=None, p=None, seed=None):
        self.p = p if p else getPrime(128)
        self.a = a if a else randrange(1, self.p)
        self.b = b if b else randrange(0, self.p)
        self.state = seed if seed else randrange(0, self.p)

    def next(self):
        self.state = (self.a * self.state + self.b) % self.p
        return self.state

    def randbytes(self, n):
        out = b''
        for _ in range(n):
            out += bytes([self.next() % 256])
        return out

    def choices(self, seq, k):
        return [seq[self.next() % len(seq)] for _ in range(k)]

    def getPrime(self, n):
        while True:
            num = self.randbytes(n // 8)
            p = bytes_to_long(num) | (1 << (n - 1)) | 1
            if isPrime(p):
                return p

    def getrandbits(self, n):
        num = self.randbytes((n + 7) // 8)
        return bytes_to_long(num) & ((1 << n) - 1)

    def __repr__(self):
        return f'a = {self.a}\nb = {self.b}\np = {self.p}'

def go_backward(state, steps, a, b, p):
    inv_a = pow(a,-1, p)
    s = state
    for _ in range(steps):
        s = (inv_a * (s - b)) % p
    return s

def attack(y_msb, k, s, m, a, c):
    """
    Fixed lattice attack for MSB-truncated LCG with non-zero increment.
    Uses ~ t = len(y_msb) >= 2*s samples for reliability.
    """
    t = len(y_msb)
    diff_bits = k - s
    y = vector(ZZ, y_msb)
    delta = ZZ(0)
    for i in range(t):
        y[i] = (y[i] * (ZZ(1) << diff_bits) - delta) % m
        delta = (a * delta + c) % m

    B = matrix(ZZ, t, t)
    B[0, 0] = m
    for i in range(1, t):
        B[i, 0] = pow(a, i, m)  
        B[i, i] = ZZ(-1)

    B = B.LLL()

    b_vec = B * y
    for i in range(t):
        b_vec[i] = round(QQ(b_vec[i]) / m) * m - b_vec[i]

    errors = B.solve_right(b_vec)
    x_hom = [int(y[i] + errors[i]) for i in range(t)]

    delta = ZZ(0)
    x = []
    for i in range(t):
        xi = (x_hom[i] + delta) % m
        x.append(int(xi))
        delta = (a * delta + c) % m

    return x

io = remote("pwn-ce8ba3d260.challenge.xctf.org.cn", 9999, ssl=True)
sa = lambda x: io.sendlineafter(b'>>> ', x.encode())

sa("G")
a = int(io.recvline().decode().strip().partition('= ')[-1])
b = int(io.recvline().decode().strip().partition('= ')[-1])
p = int(io.recvline().decode().strip().partition('= ')[-1])

cnt = 25
collect = []
for i in range(cnt):
    sa("L")
    user = ''.join(random.choices(string.ascii_letters, k=8)).encode()
    io.recvuntil(b": ")
    vcode_hex = io.recvline().decode().strip()
    vcode = bytes_to_long(unhexlify(vcode_hex))

    io.sendlineafter(b'Username: ', user)
    io.sendlineafter(b'Password: ', user)
    io.sendlineafter(b"Verification code: ", vcode_hex.encode())
    ss = [int(j) for j in long_to_bytes(vcode)]
    collect.append(ss)

fss = [x for sublist in collect for x in sublist]
print(f"Leaks: {fss}")

## Grok stuff for a while
# LSB -> MSB transform
s_bit = 8
k_bit = 128
I = pow(1 << s_bit,-1,  p)
c_prime = (b * I) % p
msb_list = []
for yl in fss:
    g = (yl * I) % p
    msb = g >> (k_bit - s_bit)
    msb_list.append(msb)

print(f"Transformed MSBs: {msb_list}")

# Recover S states
S_states = attack(msb_list, k_bit, s_bit, p, a, c_prime)
print("Recovered S:", S_states)

# Back to X
X_states = [(S * (1 << s_bit)) % p for S in S_states]
print("Recovered X:", X_states)

# Verify (should all match; rare mismatch? re-run with cnt+=1)
matches = [X % 256 == leak for X, leak in zip(X_states, fss)]
print("Matches:", matches)

print([x % 256 for x in X_states])
print(fss)
if not all(matches):
    print("Rare wrap; increase cnt and re-run.")

## Grok stuff ends here 

steps_to_initial = 33
s0 = go_backward(X_states[0], steps_to_initial, a, b, p)


prng_pass = PRNG(a=a, b=b, p=p, seed=s0)
seq = ascii_letters + digits 
pass_str = ''.join(prng_pass.choices(seq, 32))
admin_hash = pass_str.encode()
print(f"Admin hash: {admin_hash}")

prng_key = PRNG(a=a, b=b, p=p, seed=X_states[-1])

sa('L')
io.recvuntil(b": ")
vcode_hex = io.recvline().decode().strip()
prng_key.randbytes(4)  # Local advance


io.sendlineafter(b'Username: ', b'admin')
io.sendlineafter(b'Password: ', admin_hash)
io.sendlineafter(b"Verification code: ", vcode_hex.encode())

sa("R")
key = prng_key.randbytes(16)
iv = prng_key.randbytes(16)
ct_hex = io.recvline().strip().decode()
ct = unhexlify(ct_hex)
aes = AES.new(key, AES.MODE_CBC, iv)
pt = unpad(aes.decrypt(ct), 16)
print("Flag:", pt.decode())
io.close()
```
