---
date: 2024-12-10
title: "LakeCTF 2024 Crypto - Wild Signatures"
toc: true
description: "Writeup on a LakeCTF'24 crypto challenge"
math: true
cover: /images/covers/wildsigs_top.gif
tags: 
- EdDSA
- Elliptic Curves
categories: Writeup
---



## Challenge Description

```
Can you even sign? Help leo get the flag as soon as possible.
nc chall.polygl0ts.ch 9001
```

## Source files

[server.py](./server.py) \
[Dockerfile](./Dockerfile) \
[compose.yaml](./compose.yaml)


## Source Analysis

```python
#!/usr/bin/env python3
import os

from Crypto.PublicKey import ECC
from Crypto.Signature import eddsa

flag = os.environ.get("FLAG", "EPFL{test_flag}")

msgs = [
    b"I, gallileo, command you to give me the flag",
    b"Really, give me the flag",
    b"can I haz flagg",
    b"flag plz"
]

leos_key = ECC.generate(curve='ed25519')
sigs = [ leos_key.public_key().export_key(format='raw') + eddsa.new(leos_key, 'rfc8032').sign(msg) for msg in msgs]

def parse_and_vfy_sig(sig: bytes, msg: bytes):
    pk_bytes = sig[:32]
    sig_bytes = sig[32:]
    
    pk = eddsa.import_public_key(encoded=pk_bytes)

    if pk.pointQ.x == 0:
        print("you think you are funny")
        raise ValueError("funny user")

    eddsa.new(pk, 'rfc8032').verify(msg, sig_bytes)

if __name__ == "__main__":
    try:
        print("if you really are leo, give me public keys that can verify these signatures")
        for msg, sig in zip(msgs, sigs):
            print(sig[64:].hex())
            user_msg = bytes.fromhex(input())

            # first 64 bytes encode the public key
            if len(user_msg) > 64 or len(user_msg) == 0:
                print("you're talking too much, or too little")
                exit()

            to_verif = user_msg + sig[len(user_msg):]

            parse_and_vfy_sig(to_verif, msg)
            print("it's valid")

    except ValueError as e:
        print(e)
        exit()

    print(flag)
```

From the source it is evident that there is EdDSA happening. I just went for the standard Cryptanalysis procedure on this one, that is, to just treat it as a Black-box and observe the outputs.

### Signature generation

```python
sigs = [ leos_key.public_key().export_key(format='raw') + eddsa.new(leos_key, 'rfc8032').sign(msg) for msg in msgs]
```

This is of particular interest. 
It is evident that the signature is for each message is generated by `pubkey + actual_sig of the message` and also from testing locally we can validate this:

```python
In [15]: sigs
Out[15]: 
[b"\xc6\xc9]$\xb2\xfe}\xd0\xde\xfc\xf1\x0fcZ'\x06!\xe6\xa8\x1f\x8bSP\x98\x17\xc4\xd5\xd9\xba\xf8u\xb8I)2&\xd4,/>\x7f\xc2\xc8'\xcaPd'\r\xd2I~S\xd0\xe2W\xc5Oq\xfc>\x94L\t\xbd\xb9\x895\xb4\xce\xc1\xcbF\xe1\xce\x99\x84c\x89\x13\xb1\xcbR\xddY\t\x91\xcdmU\xe0:\x9a\xd83\x0f",
 b'\xc6\xc9]$\xb2\xfe}\xd0\xde\xfc\xf1\x0fcZ\'\x06!\xe6\xa8\x1f\x8bSP\x98\x17\xc4\xd5\xd9\xba\xf8u\xb8\x02\xfe\xd5\xa8\xcf\xea\xf8\xe3\xe0\xbe\x02\xc2\x0f5\xa1\x9bE V]\xfe\xf7\xeb6(\x1c"\xc6-\x1aP{\x1c\xbb|\xbd\xfb\xa3\xb67LVc\xda-\xa7\xd3m\xc1o\x82\xd7=\xd2P\xa3\xc6D\xba\x93\xfbD\xba\x07',
 b"\xc6\xc9]$\xb2\xfe}\xd0\xde\xfc\xf1\x0fcZ'\x06!\xe6\xa8\x1f\x8bSP\x98\x17\xc4\xd5\xd9\xba\xf8u\xb8\xb6.\xee\nG{\x14\xba'\x94\xe2'\xa4\xbdK\x98\xf0\xa7c3\xac\x89\x7fb\nmo\x06\xe2\xbf\xceu<\xf9\xe7\xc2\xa8/n\xbf\xf9O`\xf9uh\xa2\xca\xf4+\xa6\xd5=mY\x1d\\3y2\x07U\xad\x0b",
 b"\xc6\xc9]$\xb2\xfe}\xd0\xde\xfc\xf1\x0fcZ'\x06!\xe6\xa8\x1f\x8bSP\x98\x17\xc4\xd5\xd9\xba\xf8u\xb8Q [\x9b=\x83~\xc56\xb5^\x1e\xdc\xa5~\xe9!\x008HLw\xf1\xd5=g\xdff\xfa\x83\x82D!\t\xfa\xd3\xd8\xc1e\x03!+\xe3\xe7\xe9\xd4b\xeb\x14\xd7\xcbN'[|&\xdf\xb0\xddU)$\xa8\r"]
```


### Main

Contrary to what the challenge requires you to send, that is, the entire pubkey, we can just send part of the pubkey and the remaining will be considered from the pre-existing signature.

```python
    to_verif = user_msg + sig[len(user_msg):]
```

So to make life easier and to pass the verification check from `parse_and_vfy_sig()` more often, we can send just a *single byte* to the server and check if it passes the verification check, if not, we close the connection and open an another one and repeat this until the signature verifies.

This is feasible as there is a **1/255** chance of us landing on the right byte. \
...so there will be a bit of waiting involved.

Note as the first 32 bytes of every signature is the same, once we hit the right byte, we send it 4 times to the server to pass the verification check completely to get the flag.

### Intended Solve?

Apparently the intended solve required us to find points of low order on this curve but this too works, overall was an easy challenge.

## Solve script

```python
from pwn import *

HOST = 'chall.polygl0ts.ch'
PORT = 9001
context.log_level = 'critical'

while True:
    io = remote(HOST,PORT)
    flag = 0
    io.recvline()
    payload = enhex(b'B').encode()
    for t in range(4):
        io.recvline()
        io.sendline(payload)
        server_response = io.recvline().decode().strip()
        print(server_response)
        if server_response!="it's valid":

            break
        else:
            print(r)
            flag = 1
    if flag:
        break

io.interactive()

# EPFL{wH4T_d0_yOu_m34n_4_W1LdC4Rd}
```






