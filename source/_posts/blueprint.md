---
date: 2025-09-14
title: "Defcamp 2025 Crypto - Blueprint"
toc: true
description: "Writeup on a Defcamp'25 crypto challenge."
cover: /images/covers/blueprint_top.jpg
tags: 
- Brute
- PRNG
- Branch and Prune
categories: Writeup
---


### Challenge Description

```
This is a sketch of a cryptosystem, nothing makes sense but some claim it is secure, show them what you got
```


### Given information

We are given the modulus N, leak which is `shuffle_chunk(p, x) ^ shuffle_chunk(q, y)`, cei_ce_au_valoarea, sefu_la_bani, k, ciphertext and the Narnia outputs from the seeds given by the user.

### Analysis

- Starting with `generate_random_shuffle()` it seeded using either seedx or seedy in the server and just returns a list after flattening each sublist within the mainlist after randomly shuffling the elements within the given split range.
- `shuffle_chunk()` takes an int, shuffles the bits based on the shuffling array that is provided which is `x` and `y`.
- `narnia()` takes the secret which is either seedx or seedy, xors it with an 5 lists which are generated by each of the seeds and randomly shuffled using a number from a CSPRNG. Each of the lists contain 17 integers as the last three integers after shuffling are not considered for xoring.

### Approach

- Any sort of MITM approach felt like it would be too computationally expensive so we went with the following:
	- Find 5 seeds such that each one of them generates a 0 at a specific bit position which when fed into the `narnia()` func would leak exactly one bit of information from the secret which is either seedx or seedy.
	- As the server permits 42 tries, we can query 21 times for seedx and do the same for seedy revealing a total of 21 lsb in both.
	- Now as seedx and seedy are 32 bit values, we can brute 2^11 * 2^11 and verify using the given `cei_ce_au_valoarea`.
-  Now that x and y are revealed, we use branch and prune to find the appropriate bits of p and q and then perform RSA decryption to get flag.

TLDR: z3 _might_ work for the last step but could not get it working. Also AI helped quite a lot :)

### Solve script

```python
from typing import List, Tuple, Optional
from pwn import *
from Crypto.Util.number import long_to_bytes,bytes_to_long, inverse
BITS = 512

def generate_random_shuffle(seed, splits):
    random.seed(seed)
    lst = list(range(BITS))
    caca = [lst[j:j+splits] for j in range(0,len(lst),splits)]
    for chunk in caca:
        random.shuffle(chunk)
    return [caca for sublist in caca for caca in sublist]

def shuffle_chunk(x, shuffle_arr):
    res = 0
    for i in range(BITS):
        bit = (x >> i) & 1
        res |= bit << shuffle_arr[i]
    return res

def inverse_perm(perm: List[int]) -> List[int]:
    inv = [0] * len(perm)
    for i, t in enumerate(perm):
        inv[t] = i
    return inv

def branch_and_prune_factor(
    n: int,
    leak: int,
    inv_x: List[int],
    inv_y: List[int],
) -> Optional[Tuple[int, int]]:

    assert len(inv_x) == BITS and len(inv_y) == BITS

    leak_bits = [(leak >> j) & 1 for j in range(BITS)]
    by_when = [[] for _ in range(BITS)]
    for j in range(BITS):
        a = inv_x[j]
        b = inv_y[j]
        t = a if a >= b else b
        by_when[t].append((a, b, leak_bits[j]))

    live_constraints: List[Tuple[int, int, int]] = []

    candidates = {(0, 0)}  
    n_low = 0  
    mask = 0

    for bit_pos in range(BITS):
        mask = (mask << 1) | 1
        n_low = n & mask

        live_constraints.extend(by_when[bit_pos])

        new_candidates = set()

        if bit_pos == 0:
            base_branches = [(1, 1)]
        else:
            base_branches = [(0, 0), (0, 1), (1, 0), (1, 1)]

        for (p_mod, q_mod) in candidates:
            for bp, bq in base_branches:
                np = p_mod | (bp << bit_pos)
                nq = q_mod | (bq << bit_pos)

                if (np * nq) & mask != n_low:
                    continue

                ok = True
                for (a, b, lb) in live_constraints:

                    xb = (np >> a) & 1
                    yb = (nq >> b) & 1
                    if (xb ^ yb) != lb:
                        ok = False
                        break

                if ok:
                    new_candidates.add((np, nq))

        candidates = new_candidates


        if not candidates:
            return None

    for p, q in candidates:
        if p * q == n:
            return (p, q)
    return None

def brute_force_seeds(partial_seedx, partial_seedy, known_mask_x, known_mask_y, sefu_la_bani, cei_ce_au_valoarea, k):
    # Assuming partial_seedx has the known bits set, and known_mask_x has 1s where bits are known for seedx
    # Similarly for seedy
    # Missing bits are where mask == 0, and we brute-force those (assuming exactly 11 missing bits each)
    
    
    for missing_x in range(1 << 11):
        seedx = partial_seedx
        bit_pos = 0
        temp_missing = missing_x
        for i in range(32):
            if not (known_mask_x & (1 << i)):
                seedx |= ((temp_missing & 1) << i)
                temp_missing >>= 1
        
        x = generate_random_shuffle(seedx, 13)
        
        for missing_y in range(1 << 11):
            seedy = partial_seedy
            bit_pos = 0
            temp_missing = missing_y
            for i in range(32):
                if not (known_mask_y & (1 << i)):
                    seedy |= ((temp_missing & 1) << i)
                    temp_missing >>= 1
            
            y = generate_random_shuffle(seedy, 7)
            
            sum_val = 0
            for i in range(16):
                term = sefu_la_bani[i] * (x[8 * i] + 2) * (y[i] + 2)
                sum_val = (sum_val + term) % k
            
            if sum_val == cei_ce_au_valoarea:
                return seedx, seedy
    
    return None, None

seeds = [[54592, 589806, 691520, 1511525, 1907923],
 [1456373, 1762619, 3246281, 5898661, 6776965],
 [405895, 765898, 2571370, 4198869, 4610898],
 [742525, 2854984, 3080733, 4055808, 4442376],
 [390601, 983414, 3571289, 3735060, 5195484],
 [3079153, 4063973, 5494148, 6770235, 7589131],
 [1494392, 2187565, 4192009, 7161644, 8169314],
 [2279714, 3489277, 4129676, 4528152, 4685760],
 [4481993, 4907857, 7193330, 7621171, 7799985],
 [2232206, 3754434, 3981656, 4144095, 4383087],
 [755696, 914511, 1948828, 2026807, 3404297],
 [405497, 2219856, 2829986, 4139443, 4929177],
 [764282, 1768025, 3857687, 4039875, 6159752],
 [1626263, 5334703, 7056022, 7491980, 10232369],
 [623324, 2611090, 2726712, 3023155, 3969667],
 [2120530, 2373027, 2925202, 3192740, 4112071],
 [849566, 1782321, 3684491, 5440985, 6447854],
 [246366, 1472630, 3757499, 5417180, 6533879],
 [2899292, 3895269, 6262368, 6541294, 6772557],
 [1847954, 4937715, 6414473, 6886687, 7198114],
 [336133, 2430365, 4725975, 4944450, 7272566]]

p = remote('35.198.141.47' ,31081) # Change to challenge host/port


p.sendline(b"get_data")
p.recvuntil(b"n = ")
n = int(p.recvline().strip())
p.recvuntil(b"leak = ")
leak = int(p.recvline().strip())
p.recvuntil(b"sefu_la_bani = ")
sefu_la_bani = eval(p.recvline().strip())
p.recvuntil(b"cei_ce_au_valoarea = ")
cei_ce_au_valoarea = int(p.recvline().strip())
p.recvuntil(b"k = ")
k = int(p.recvline().strip())
p.recvuntil(b"ct = ")
ct = int(p.recvline().strip())

log.info(f"n = {n}")
log.info(f"ct = {ct}")


acc = 0
for attempt in range(21):
    p.sendline(f"query x {' '.join(map(str, seeds[attempt]))}".encode())
    p.recvuntil(b"Output: ")
    val = int(p.recvline().strip())
    val &= 0xffffffff  # force 32-bit domain, just in case
    bit_k = (val >> attempt) & 1             
    acc |= (bit_k << attempt)
lowx = acc

acc = 0
for attempt in range(21):
    p.sendline(f"query y {' '.join(map(str, seeds[attempt]))}".encode())
    p.recvuntil(b"Output: ")
    val = int(p.recvline().strip())
    val &= 0xffffffff  # force 32-bit domain, just in case
    bit_k = (val >> attempt) & 1             
    acc |= (bit_k << attempt)
lowy = acc

log.info(f"Lower 21 bits seedx = {lowx}")
log.info(f"Lower 21 bits seedy = {lowy}")

seedx, seedy = brute_force_seeds(lowx, lowy, (1<<21)-1, (1<<21)-1, sefu_la_bani, cei_ce_au_valoarea, k)
log.info(f"Found seedx = {seedx}")
log.info(f"Found seedy = {seedy}")

if not seedx or not seedy:
    log.error("Failed to find valid seeds")
    exit()
    
x = generate_random_shuffle(seedx, 13)
y = generate_random_shuffle(seedy, 7)
p_val, q_val = branch_and_prune_factor(n, leak, inverse_perm(x), inverse_perm(y))
if p_val and q_val:
    log.info(f"p = {p_val}")
    log.info(f"q = {q_val}")
    
    e = 65537
    phi = (p_val - 1) * (q_val - 1)
    d = inverse(e, phi)
    
    m = pow(ct, d, n)
    flag = long_to_bytes(m)
    log.success(f"Flag: {flag.decode()}")

p.close()
```

Flag : `CTF{w0w_you_actually_deciphered_the_blueprint_sorry_it_took_so_long_had_to_patch_unintendeds_skibidi_have_fun_with_the_rest}`

